/*
 *   SakaiScript.jws - updated for Sakai 2.6
 *
 */
 
import java.util.Date;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Iterator;
import java.util.Set;
import java.util.Collection;
import org.sakaiproject.tool.api.Session;
import org.sakaiproject.tool.cover.SessionManager;
import org.sakaiproject.exception.IdUnusedException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.sakaiproject.authz.api.AuthzGroup;
import org.sakaiproject.authz.api.Role;
import org.sakaiproject.authz.api.Member;
import org.sakaiproject.user.cover.UserDirectoryService;
import org.sakaiproject.tool.api.Tool;
import org.sakaiproject.site.api.ToolConfiguration;
import org.sakaiproject.site.api.Site;
import org.sakaiproject.site.api.Group;
import org.sakaiproject.site.api.SitePage;
import org.sakaiproject.user.api.UserEdit;
import org.sakaiproject.authz.cover.AuthzGroupService;
import org.sakaiproject.user.api.User;
import org.sakaiproject.tool.cover.ToolManager;
import org.sakaiproject.site.cover.SiteService;
import org.sakaiproject.authz.cover.SecurityService;
import org.sakaiproject.site.api.SiteService.SelectionType;
import org.sakaiproject.site.api.SiteService.SortType;

import org.sakaiproject.entity.api.ResourceProperties;
import org.sakaiproject.entity.api.ResourcePropertiesEdit;

import org.sakaiproject.calendar.cover.CalendarService; 
import org.sakaiproject.calendar.api.Calendar; 
import org.sakaiproject.calendar.api.CalendarEdit; 
import org.sakaiproject.calendar.api.CalendarEvent; 
import org.sakaiproject.calendar.api.CalendarEventEdit; 
import org.sakaiproject.time.api.TimeService; 

import java.util.Properties;
import org.apache.axis.AxisFault;

import org.sakaiproject.util.FormattedText;
import org.sakaiproject.util.Xml;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

public class SakaiScript {
	
private static final Log LOG = LogFactory.getLog(SakaiScript.class);

private static final String ADMIN_SITE_REALM = "/site/!admin";
	
private Session establishSession(String id) throws AxisFault 
{
	Session s = SessionManager.getSession(id);
	
	if (s == null)
	{
		throw new AxisFault("Session "+id+" is not active");
	}
	s.setActive();
	SessionManager.setCurrentSession(s);
	return s;
}

public String checkSession(String id) {
	Session s = SessionManager.getSession(id);
	if (s == null)
	{
		return "null";
	}
	else
	{
		return id;
	}
}

/**
 * Create a new user account
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the new user
 * @param	firstname		the new user's first name
 * @param	lastname		the new user's last name
 * @param	email			the new user's email address
 * @param	type			the type of account (ie registered, guest etc). Should either match one of the !user.template.XXX realms (where XXX is the type) or be blank to inherit the !user.template permission
 * @param	password		the password for the new user
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 * This is the preferred method of adding user accounts whereby their internal ID is automatically assigned a UUID.
 *
 */
public String addNewUser( String sessionid, String eid, String firstname, String lastname, String email, String type, String password) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	if (!SecurityService.isSuperUser())
	{
		LOG.warn("NonSuperUser trying to add accounts: " + session.getUserId());
        throw new AxisFault("NonSuperUser trying to add accounts: " + session.getUserId());
	}
	try {

		User addeduser = null;
		addeduser = UserDirectoryService.addUser(null, eid, firstname, lastname, email, password, type, null);
	
	}
	catch (Exception e) {  
		LOG.warn("WS addNewUser(): " + e.getClass().getName() + " : " + e.getMessage());
        return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Create a new user account
 *
 * @param	sessionid		the id of a valid session
 * @param	id				the id of the new user that will be used internally by Sakai
 * @param	eid				the login username (ie jsmith26) of the new user
 * @param	firstname		the new user's first name
 * @param	lastname		the new user's last name
 * @param	email			the new user's email address
 * @param	type			the type of account (ie registered, guest etc). Should either match one of the !user.template.XXX realms (where XXX is the type) or be blank to inherit the !user.template permission
 * @param	password		the password for the new user
 * @return		        	success or exception message
 * @throws	AxisFault
 * 
 * This form of addUser() should only be used when you need control over the user's internal ID. Otherwise use the other form.
 * 
 */
public String addNewUser( String sessionid, String id ,String eid, String firstname, String lastname, String email, String type, String password) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	if (!SecurityService.isSuperUser())
	{
		LOG.warn("NonSuperUser trying to add accounts: " + session.getUserId());
        throw new AxisFault("NonSuperUser trying to add accounts: " + session.getUserId());
	}
	try {

		User addeduser = null;
		addeduser = UserDirectoryService.addUser(id, eid, firstname, lastname, email, password, type, null);
	
	}
	catch (Exception e) {  
		LOG.warn("WS addNewUser(): " + e.getClass().getName() + " : " + e.getMessage());
        return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a user account
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user whose account you want to remove
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String removeUser( String sessionid, String eid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		UserEdit userEdit = null;
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		UserDirectoryService.removeUser(userEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeUser(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a user's account details
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user you want to edit
 * @param	firstname		the updated firstname for the user
 * @param	lastname		the updated last name for the user
 * @param	email			the updated email address for the user
 * @param	type			the updated user type
 * @param	password		the updated password for the user
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 * Note that if you only want to change individual properties of a user's account like their email address or password, see the related web services.
 *
 */
public String changeUserInfo( String sessionid, String eid, String firstname, String lastname, String email, String type, String password) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	UserEdit userEdit = null;
	try {
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		userEdit.setFirstName(firstname);
		userEdit.setLastName(lastname);
		userEdit.setEmail(email);
		userEdit.setType(type);
		userEdit.setPassword(password);
		UserDirectoryService.commitEdit(userEdit);
	}
	catch (Exception e) { 
		UserDirectoryService.cancelEdit(userEdit);
		LOG.error("WS removeUser(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a user's firstname/lastname
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user you want to edit
 * @param	firstname		the updated firstname for the user
 * @param	lastname		the updated last name for the user
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String changeUserName( String sessionid, String eid, String firstname, String lastname) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	UserEdit userEdit = null;
	try {
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		userEdit.setFirstName(firstname);
		userEdit.setLastName(lastname);
		UserDirectoryService.commitEdit(userEdit);
	}
	catch (Exception e) { 
		UserDirectoryService.cancelEdit(userEdit);
		LOG.error("WS changeUserName(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a user's email address
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user you want to edit
 * @param	email			the updated email address for the user
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String changeUserEmail( String sessionid, String eid, String email) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	UserEdit userEdit = null;
	try {
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		userEdit.setEmail(email);
		UserDirectoryService.commitEdit(userEdit);
	}
	catch (Exception e) { 
		UserDirectoryService.cancelEdit(userEdit);
		LOG.error("WS changeUserEmail(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a user's user type
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user you want to edit
 * @param	type			the updated user type. See addNewUser() for an explanation of what this field means
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String changeUserType( String sessionid, String eid, String type) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	UserEdit userEdit = null;
	try {
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		userEdit.setType(type);
		UserDirectoryService.commitEdit(userEdit);
	}
	catch (Exception e) { 
		UserDirectoryService.cancelEdit(userEdit);
		LOG.error("WS changeUserType(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a user's password
 *
 * @param	sessionid		the id of a valid session
 * @param	eid				the login username (ie jsmith26) of the user you want to edit
 * @param	password		the password for the user
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String changeUserPassword( String sessionid, String eid, String password) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	UserEdit userEdit = null;
	try {
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		userEdit = UserDirectoryService.editUser(userid);
		userEdit.setPassword(password);
		UserDirectoryService.commitEdit(userEdit);
	}
	catch (Exception e) {
		UserDirectoryService.cancelEdit(userEdit);
		LOG.error("WS changeUserPassword(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Get a user's email address based on their session id
 *
 * @param	sessionid		the session id of the user who's email address you wish to retrieve
 * @return		        	their email address
 * @throws	AxisFault
 *
 */
public String getUserEmail( String sessionid ) throws AxisFault
{
	Session session = establishSession(sessionid);
	User user = UserDirectoryService.getCurrentUser();
	return user.getEmail();
}

/**
 * Get a user's display name based on their session id
 *
 * @param	sessionid		the session id of the user who's display name you wish to retrieve
 * @return		        	success or exception message
 * @throws	AxisFault
 *
 */
public String getUserDisplayName( String sessionid ) throws AxisFault
{
	Session session = establishSession(sessionid);
	User user = UserDirectoryService.getCurrentUser();
	return user.getDisplayName();
}

/**
 * Gets the display name for a given user 
 *
 * Differs from original above as that one uses the session to get the displayname hence you must know this in advance or be logged in to the web services
 * with that user. This uses a userid as well so we could be logged in as admin and retrieve the display name for any user.
 * 
 * @param	sessionid	the id of a valid session
 * @param	userid		the login username (ie jsmith26) of the user you want the display name for
 * @return				the display name for the user
 * @throws	AxisFault	
 *
 */
public String getUserDisplayName( String sessionid, String userid ) throws AxisFault
{
	Session session = establishSession(sessionid);
	try {
		User user = UserDirectoryService.getUserByEid(userid);
		return user.getDisplayName();
	} catch (Exception e) {  
	 	LOG.error("WS getUserDisplayName() failed for user: " + userid + " : " + e.getClass().getName() + " : " + e.getMessage());
		return "";
	}
}

/**
 * Create user-group to specified worksite (as if it had been added in Worksite Setup)
 *
 * @param 	sessionid 	the id of a valid session
 * @param 	siteid 		the id of the site you want the group created in
 * @param 	grouptitle 	the name of the new group
 * @param 	groupdesc 	the description of the new group
 * @return groupid 		if successful/exception
 *
 */
private static final String GROUP_PROP_WSETUP_CREATED = "group_prop_wsetup_created";
public String addGroupToSite( String sessionid, String siteid, String grouptitle, String groupdesc ) throws AxisFault
{
	Session session = establishSession(sessionid);
	try
	{
		Site site = SiteService.getSite(siteid);
		Group group = site.addGroup();
		group.setTitle(grouptitle);
		group.setDescription(groupdesc);
		group.getProperties().addProperty(GROUP_PROP_WSETUP_CREATED, Boolean.TRUE.toString());

		SiteService.save(site);
		return group.getId();
	}
	catch (Exception e)
	{
		LOG.error("WS addGroupToSite(): " + e.getClass().getName() + " : " + e.getMessage());
		return "";

	}
} 

/**
 * Add member to specified worksite group
 *
 * @param 	sessionid 	the id of a valid session
 * @param 	siteid 		the id of the site that the group is in
 * @param 	groupid 	the id of the group you want to add the user to
 * @param 	userid 		the internal userid of the member to add
 * @return 	true 		if successful/exception
 *
 * TODO: This is not returning false if it fails (ie if user isn't in site to begin with). SAK-15334
 */
public boolean addMemberToGroup( String sessionid, String siteid, String groupid, String userid ) throws AxisFault
{
	Session session = establishSession(sessionid);
	try
	{
		Site site = SiteService.getSite(siteid);
		Group group = site.getGroup(groupid);
		if ( group == null )
			return false;
	
		Role r = site.getUserRole(userid);
		Member m = site.getMember(userid);
		group.addMember(userid, r != null ? r.getId() : "", m != null ? m.isActive() : true,	false);
		SiteService.save(site);
		return true;
	}
	catch (Exception e)
	{
		LOG.error("WS addMemberToGroup(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return false;
	}
}

/**
 * Create a new authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the new authzgroup
 * @return					success or exception message
 *
 */
public String addNewAuthzGroup(String sessionid, String authzgroupid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = null;
		authzgroup = AuthzGroupService.addAuthzGroup(authzgroupid);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS addNewAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to remove
 * @return					success or exception message
 *
 */
public String removeAuthzGroup( String sessionid, String authzgroupid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		AuthzGroupService.removeAuthzGroup(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Add a role to an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to add the role to
 * @param 	roleid		 	the id of the role to add
 * @param 	description 	the description for the new role
 * @return					success or exception message
 *
 */
public String addNewRoleToAuthzGroup( String sessionid, String authzgroupid, String roleid, String description) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		Role role = authzgroup.addRole(roleid);
		role.setDescription(description);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS addNewRoleToAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove all roles that exist in an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to remove the roles from
 * @return					success or exception message
 *
 */
 public String removeAllRolesFromAuthzGroup( String sessionid, String authzgroupid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		authzgroup.removeRoles();
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeAllRolesFromAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a role from an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to remove the role from
 * @param 	roleid		 	the id of the role to remove
 * @return					success or exception message
 *
 * Note: This web service has been modified, see SAK-15334
 */
public String removeRoleFromAuthzGroup( String sessionid, String authzgroupid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		//check Role exists
		Role role = authzgroup.getRole(roleid);
		if(role == null) {
			//log warning, but still continue so as not to break any existing implementations
			LOG.warn("WS removeRoleFromAuthzGroup(): authzgroup: " + authzgroupid + " does not contain role: " + roleid);
		}
		authzgroup.removeRole(roleid);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeRoleFromAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Add a function to a role in an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup that the role is in
 * @param 	roleid		 	the id of the role to add a function to
 * @param	functionname	the name of the new function eg content.new
 * @return					success or exception message
 *
 * TODO: fix for if the functionname doesn't exist, it is still returning success - SAK-15334
 */
public String allowFunctionForRole( String sessionid, String authzgroupid, String roleid, String functionname) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	// check that ONLY super user's are accessing this (see SAK-18494)
	if (!SecurityService.isSuperUser(session.getUserId())) {
		LOG.warn("WS allowFunctionForRole(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS allowFunctionForRole(): Permission denied. Restricted to super users.");
	}

	try {
		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		Role role = authzgroup.getRole(roleid);
		role.allowFunction(functionname);
		AuthzGroupService.save(authzgroup);
	}
	catch (Exception e) {  
		LOG.error("WS allowFunctionForRole(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove all functions from a role in an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup that the role is in
 * @param 	roleid		 	the id of the role to remove the functions from
 * @return					success or exception message
 *
 */
public String disallowAllFunctionsForRole( String sessionid, String authzgroupid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		Role role = authzgroup.getRole(roleid);
		role.disallowAll();
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS disallowAllFunctionsForRole(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a function from a role in an authzgroup (realm)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup that the role is in
 * @param 	roleid		 	the id of the role to remove the function from
 * @param	functionname	the name of the function to remove
 * @return					success or exception message
 *
 * TODO: fix for if the functionname doesn't exist, it is still returning success - SAK-15334
 */
public String disallowFunctionForRole( String sessionid, String authzgroupid, String roleid, String functionname) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		Role role = authzgroup.getRole(roleid);
		role.disallowFunction(functionname);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS disallowFunctionForRole(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Edit a role's description
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup that the role exists in
 * @param 	roleid		 	the id of the role to edit
 * @param 	description 	the updated description for the role
 * @return					success or exception message
 *
 */
public String setRoleDescription( String sessionid, String authzgroupid, String roleid, String description) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		Role role = authzgroup.getRole(roleid);
		role.setDescription(description);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS setRoleDescription(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Add a user to an authgroup with the given role
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	eid	 			the login username (ie jsmith26) of the user you want to add
 * @param 	authzgroupid 	the id of the authzgroup to add the user to
 * @param 	roleid		 	the id of the role to add the user to in the authzgroup
 * @return					success or exception message
 *
 * Note: This web service has been modified, see SAK-15334
 */
public String addMemberToAuthzGroupWithRole( String sessionid, String eid, String authzgroupid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		//check Role exists
		Role role = authzgroup.getRole(roleid);
		if(role == null) {
			//log warning and return error as it would return success even if it failed
			LOG.error("WS addMemberToAuthzGroupWithRole(): authzgroup: " + authzgroupid + " does not contain role: " + roleid);
			return "WS addMemberToAuthzGroupWithRole(): authzgroup: " + authzgroupid + " does not contain role: " + roleid;
		}
		
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		authzgroup.addMember(userid,roleid,true,false);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS addMemberToAuthzGroupWithRole(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a user from an authgroup
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	eid	 			the login username (ie jsmith26) of the user you want to remove
 * @param 	authzgroupid 	the id of the authzgroup to remove the user from
 * @return					success or exception message
 *
 */
 public String removeMemberFromAuthzGroup( String sessionid, String eid, String authzgroupid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		authzgroup.removeMember(userid);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeMemberFromAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove all users from an authgroup
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to remove the users from
 * @return					success or exception message
 *
 */
 public String removeAllMembersFromAuthzGroup( String sessionid, String authzgroupid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup realmEdit = AuthzGroupService.getAuthzGroup(authzgroupid);
		realmEdit.removeMembers();
		AuthzGroupService.save(realmEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeAllMembersFromAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Set the role that allows maintenance on the given authgroup
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	authzgroupid 	the id of the authzgroup to edit
 * @param 	roleid		 	the id of the role to to set
 * @return					success or exception message
 *
 * TODO: fix for if the role doesn't exist in the authzgroup, it is still returning success - SAK-15334
 */
 public String setRoleForAuthzGroupMaintenance( String sessionid, String authzgroupid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		authzgroup.setMaintainRole(roleid);
		AuthzGroupService.save(authzgroup);
	
	}
	catch (Exception e) {  
		LOG.error("WS setRoleForAuthzGroupMaintenance(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Add a user to a site with a given role
 *
 * @param 	sessionid 	the id of a valid session
 * @param 	siteid 		the id of the site to add the user to
 * @param 	eid		 	the login username (ie jsmith26) of the user you want to add to the site
 * @param 	roleid		the id of the role to to give the user in the site
 * @return				success or exception message
 *
 * TODO: fix for if the role doesn't exist in the site, it is still returning success - SAK-15334
 */
public String addMemberToSiteWithRole(String sessionid, String siteid, String eid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {
		Site site = SiteService.getSite(siteid);
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		site.addMember(userid,roleid,true,false);
		SiteService.save(site);
	}
	catch (Exception e) {  
		LOG.error("WS addMemberToSiteWithRole(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Create a new site
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the new site (ie test123)
 * @param 	title 			the title of the new site
 * @param 	description 	the full description for the new site
 * @param 	shortdesc 		the short description for the new site
 * @param 	iconurl 		the url to an icon for the site (on the default skin should not be more than 100px wide)
 * @param 	infourl 		the url to a page of information about the site (this is added to the Site Information portlet)
 * @param 	joinable 		should this site be joinable?
 * @param 	joinerrole 		if joinable, the role to assign users that join this site
 * @param 	published 		should this site be made available to participants of the site now? 
 * @param 	publicview 		should this site be shown on the public list of sites?
 * @param 	skin 			the id of the skin for this site, from the list in /library/skin/SKIN
 * @param 	type 			the type of site ie project, course, etc, or any type defined as !site.template.TYPE. If blank will inherit !site.template roles/permissions
 * @return					success or exception message
 *
 * Note that this will create an empty site with no tools. If you would like to create a site from a template, ie inherit its tool structure (not content), see copySite()
 *
 */
public String addNewSite( String sessionid, String siteid, String title, String description, String shortdesc, String iconurl, String infourl, boolean joinable, String joinerrole, boolean published, boolean publicview, String skin, String type) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

	    // check description
	    if (description != null) {
	        StringBuilder alertMsg = new StringBuilder();
	        description = FormattedText.processFormattedText(description, alertMsg);
	        if (description == null) {
	        	throw new AxisFault("Site description markup rejected: " + alertMsg.toString());
	        }
	    }            
	    
		Site siteEdit = null;
		siteEdit = SiteService.addSite(siteid, type);
		siteEdit.setTitle(title);
		siteEdit.setDescription(description);
		siteEdit.setShortDescription(shortdesc);
		siteEdit.setIconUrl(iconurl);
		siteEdit.setInfoUrl(infourl);
		siteEdit.setJoinable(joinable);
		siteEdit.setJoinerRole(joinerrole);
		siteEdit.setPublished(published);
		siteEdit.setPubView(publicview);
		siteEdit.setSkin(skin);
		siteEdit.setType(type);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS addNewSite(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a site
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to remove
 * @return					success or exception message
 *
 */
public String removeSite( String sessionid, String siteid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		SiteService.removeSite(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS removeSite(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Create a new site based on another site. This will copy its tool structure, but not its content
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteidtocopy	the id of the site to base this new site on
 * @param 	siteid 			the id of the new site (ie test123)
 * @param 	title 			the title of the new site
 * @param 	description 	the full description for the new site
 * @param 	shortdesc 		the short description for the new site
 * @param 	iconurl 		the url to an icon for the site (on the default skin should not be more than 100px wide)
 * @param 	infourl 		the url to a page of information about the site (this is added to the Site Information portlet)
 * @param 	joinable 		should this site be joinable?
 * @param 	joinerrole 		if joinable, the role to assign users that join this site
 * @param 	published 		should this site be made available to participants of the site now? 
 * @param 	publicview 		should this site be shown on the public list of sites?
 * @param 	skin 			the id of the skin for this site, from the list in /library/skin/SKIN
 * @param 	type 			the type of site ie project, course, etc, or any type defined as !site.template.TYPE. If blank will inherit !site.template roles/permissions
 * @return					success or exception message
 *
 */
public String copySite( String sessionid, String siteidtocopy, String newsiteid, String title, String description, String shortdesc, String iconurl, String infourl, boolean joinable, String joinerrole, boolean published, boolean publicview, String skin, String type) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site site = SiteService.getSite(siteidtocopy);
		
		// If not admin, check maintainer membership in the source site
		if (!SecurityService.isSuperUser(session.getUserId()) &&
			!SecurityService.unlock(SiteService.SECURE_UPDATE_SITE, site.getReference())) {
				LOG.warn("WS copySite(): Permission denied. Must be super user to copy a site in which you are not a maintainer.");
				throw new AxisFault("WS copySite(): Permission denied. Must be super user to copy a site in which you are not a maintainer.");
		}
		
		// check description
		if (description != null) {
	        	StringBuilder alertMsg = new StringBuilder();
	        	description = FormattedText.processFormattedText(description, alertMsg);
			if (description == null) {
	        		throw new AxisFault("Site description markup rejected: " + alertMsg.toString());
	        	}
		}            
	    
		Site siteEdit = SiteService.addSite(newsiteid, site);
		siteEdit.setTitle(title);
		siteEdit.setDescription(description);
		siteEdit.setShortDescription(shortdesc);
		siteEdit.setIconUrl(iconurl);
		siteEdit.setInfoUrl(infourl);
		siteEdit.setJoinable(joinable);
		siteEdit.setJoinerRole(joinerrole);
		siteEdit.setPublished(published);
		siteEdit.setPubView(publicview);
		siteEdit.setSkin(skin);
		siteEdit.setType(type);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS copySite(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Create a new page in a site. A page holds one or more tools and is shown in the main navigation section. You will still need to add tools to this page.
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to add the page to
 * @param 	pagetitle 		the title of the new page
 * @param 	pagelayout 		single or double column (0 or 1). Any other value will revert to 0.
 * @return					success or exception message
 *
 */
public String addNewPageToSite( String sessionid, String siteid, String pagetitle, int pagelayout) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		SitePage sitePageEdit = null;
		siteEdit = SiteService.getSite(siteid);
		sitePageEdit = siteEdit.addPage();
		sitePageEdit.setTitle(pagetitle);
		sitePageEdit.setLayout(pagelayout);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS addNewPageToSite(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Remove a page from a site
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to remove the page from
 * @param 	pagetitle 		the title of the page to remove
 * @return					success or exception message
 *
 * TODO: fix for if the page title is blank it removes nothing and is still returning success - SAK-15334
 * TODO: fix for ConcurrentModficationException being thrown - SAK-15337. Is this because it removes via pagetitle but can allow multiple page titles of the same name?
 */
public String removePageFromSite( String sessionid, String siteid, String pagetitle) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		List pageEdits = siteEdit.getPages();
		for (Iterator i = pageEdits.iterator(); i.hasNext();)
		{
			SitePage pageEdit = (SitePage) i.next();
			if (pageEdit.getTitle().equals(pagetitle))
				siteEdit.removePage(pageEdit);
		}
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS removePageFromSite(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Add a new tool to a page in a site
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to add the page to
 * @param 	pagetitle 		the title of the page to add the tool to
 * @param 	tooltitle 		the title of the new tool (ie Resources)
 * @param 	toolid 			the id of the new tool (ie sakai.resources)
 * @param 	layouthints 	where on the page this tool should be added, in 'row, col' and 0 based, ie first column, first tool='0,0'; Second column third tool = '1,2'
 * @return					success or exception message
 *
 * TODO: fix for if any values (except sessionid and siteid) are blank or invalid, it is still returning success - SAK-15334
 */
public String addNewToolToPage( String sessionid, String siteid, String pagetitle, String tooltitle, String toolid, String layouthints) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = SiteService.getSite(siteid);
		
		// Check that the tool is visible (not stealthed) and available for this site type (category)
		if (!SecurityService.isSuperUser(session.getUserId())) {

			Set categories = new HashSet<String>();
			Set<Tool> visibleTools = ToolManager.findTools(categories, null);

			boolean toolVisible = false;
			for (Tool tool : visibleTools) {
				if (tool.getId().equals(toolid)) {
					toolVisible = true;
				}
			}

			if (!toolVisible) {
				LOG.warn("WS addNewToolToPage(): Permission denied. Must be super user to add a stealthed tool to a site.");
				throw new AxisFault("WS addNewToolToPage(): Permission denied. Must be super user to add a stealthed tool to a site.");
			}

			categories.add(siteEdit.getType());		
			Set<Tool> availableTools = ToolManager.findTools(categories, null);

			boolean toolAvailable = false;
			for (Tool tool : availableTools) {
				if (tool.getId().equals(toolid)) {
					toolAvailable = true;
				}
			}

			if (!toolAvailable) {
				LOG.warn("WS addNewToolToPage(): Permission denied. Must be super user to add a tool which is not available for this site type.");
				throw new AxisFault("WS addNewToolToPage(): Permission denied. Must be super user to add a tool which is not available for this site type.");
			}
		}
		
		List pageEdits = siteEdit.getPages();
		for (Iterator i = pageEdits.iterator(); i.hasNext();)
		{
			SitePage pageEdit = (SitePage) i.next();
			if (pageEdit.getTitle().equals(pagetitle))
			{
				ToolConfiguration tool = pageEdit.addTool();
				Tool t = tool.getTool();
				
				tool.setTool(toolid, ToolManager.getTool(toolid));
				tool.setTitle(tooltitle);
				//toolEdit.setTitle(tooltitle);
				//toolEdit.setToolId(toolid);
				tool.setLayoutHints(layouthints);
			}
		}
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS addNewToolToPage(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Add a property to a tool on a page in a site
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to add the page to
 * @param 	pagetitle 		the title of the page the tool exists in
 * @param 	tooltitle 		the title of the tool to add the property to
 * @param 	propname 		the name of the property
 * @param 	propvalue 		the value of the property
 * @return					success or exception message
 *
 * TODO: fix for if any values (except sessionid and siteid) are blank or invalid, it is still returning success - SAK-15334
 */
public String addConfigPropertyToTool( String sessionid, String siteid, String pagetitle, String tooltitle, String propname, String propvalue) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = SiteService.getSite(siteid);
		List pageEdits = siteEdit.getPages();
		for (Iterator i = pageEdits.iterator(); i.hasNext();)
		{
			SitePage pageEdit = (SitePage) i.next();
			if (pageEdit.getTitle().equals(pagetitle))
			{
				List toolEdits = pageEdit.getTools();
				for (Iterator j = toolEdits.iterator(); j.hasNext();)
				{
					ToolConfiguration tool = (ToolConfiguration) j.next();
					Tool t = tool.getTool();
					if (tool.getTitle().equals(tooltitle))
					{
						Properties propsedit = tool.getPlacementConfig();
						propsedit.setProperty(propname, propvalue);
					}
				}
			}
		}
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS addConfigPropertyToTool(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Check if a user exists (either as an account in Sakai or in any external provider)
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	eid 			the login username (ie jsmith26) of the user to check for
 * @return					true/false
 *
 */
public boolean checkForUser(String sessionid, String eid) throws AxisFault
{
	Session s = establishSession(sessionid);
	
	try {
		User u = null;
		String userid = UserDirectoryService.getUserByEid(eid).getId();
		u = UserDirectoryService.getUser(userid);
		if (u != null) {
			return true;
		} else {
			return false;
		}
	}
	catch (Exception e) {
		LOG.error("WS checkForUser(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}

/**
 * Check if a site exists
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	siteid 			the id of the site to check for
 * @return					true/false
 *
 */
 public boolean checkForSite(String sessionid, String siteid) throws AxisFault
{
	Session s = establishSession(sessionid);
	
	try {
		Site site = null;
		site = SiteService.getSite(siteid);
		if (site != null) {
			return true;
		} else {
			return false;
		}
	}
	catch (Exception e) {
		LOG.error("WS checkForSite(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}

/**
 * Check if a user exists in the authzgroup (or site) with the given role
 *
 * @param 	sessionid 		the id of a valid session
 * @param 	eid 			the login username (ie jsmith26) of the user to check for
 * @param 	authzgroupid 	the id of the authzgroup to check in. If this is a site it should be of the form /site/SITEID
 * @param 	role 			the id of the role for the user in the site
 * @return					true/false
 *
 */
public boolean checkForMemberInAuthzGroupWithRole(String sessionid, String eid, String authzgroupid, String role) throws AxisFault
{
	Session s = establishSession(sessionid);
	
	if (ADMIN_SITE_REALM.equalsIgnoreCase(authzgroupid) && !SecurityService.isSuperUser(s.getUserId())) {
		LOG.warn("WS checkForMemberInAuthzGroupWithRole(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS checkForMemberInAuthzGroupWithRole(): Permission denied. Restricted to super users.");
	}
	
	try {
		AuthzGroup authzgroup = null; 
		authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		if (authzgroup == null) {
			return false;
		} else {
			String userid = UserDirectoryService.getUserByEid(eid).getId();
			return authzgroup.hasRole(userid, role);
		}
	}
	catch (Exception e) {
		LOG.error("WS checkForMemberInAuthzGroupWithRole(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}

/**
 * Return XML document listing all sites user has read or write access based on their session id.
 *
 * @param 	sessionid 		the session id of a user who's list of sites you want to retrieve
 * @param 	eid 			the login username (ie jsmith26) of the user to check for
 * @param 	authzgroupid 	the id of the authzgroup to check in. If this is a site it should be of the form /site/SITEID
 * @param 	role 			the id of the role for the user in the site
 * @return					xml or an empty list <list/>. The return XML format is below:
 *<list>
 *	<item>
 *		<siteId>!admin</siteId>
 *		<siteTitle>Administration Workspace</siteTitle>
 *	</item>
 *	<item>
 *		...
 *	</item>
 *	...
 *</list>
 *
 */
public String getSitesUserCanAccess(String sessionid) throws AxisFault
{
	Session s = establishSession(sessionid);
	
	try 
	{
		List allSites = SiteService.getSites(SelectionType.ACCESS, null, null,
														  null, SortType.TITLE_ASC, null);
		List moreSites = SiteService.getSites(SelectionType.UPDATE, null, null,
															null, SortType.TITLE_ASC, null);
		
		if ((allSites == null || moreSites == null) || (allSites.size() == 0 && moreSites.size() == 0)) {
			return "<list/>";
		}

		// Remove duplicates and combine two lists
		allSites.removeAll( moreSites );
		allSites.addAll( moreSites );
		
		Document dom = Xml.createDocument();
		Node list = dom.createElement("list");
		dom.appendChild(list);
		
		for (Iterator i = allSites.iterator(); i.hasNext();)
		{
		   Site site = (Site)i.next();
			Node item = dom.createElement("item");
			Node siteId = dom.createElement("siteId");
			siteId.appendChild( dom.createTextNode(site.getId()) );
			Node siteTitle = dom.createElement("siteTitle");
			siteTitle.appendChild( dom.createTextNode(site.getTitle()) );
			
			item.appendChild(siteId);
			item.appendChild(siteTitle);
			list.appendChild(item);
		}
		
		return Xml.writeDocumentToString(dom);
	}
	catch (Exception e) 
	{
		LOG.error("WS getSitesUserCanAccess(): " + e.getClass().getName() + " : " + e.getMessage());
		return "<exception/>";
	}
}

/** 
* Get a site's title 
* 
* @param	sessionid	the id of a valid session
* @param	siteid		the id of the site you want the title of 
* @return				title of the site or string containing error 
* @throws AxisFault 
* 
*/ 
public String getSiteTitle(String sessionid, String siteid) throws AxisFault { 
	
	Session s = establishSession(sessionid); 

	String siteTitle = ""; 

	try { 
		Site site = SiteService.getSite(siteid); 
		siteTitle = site.getTitle(); 
	} 
	catch (Exception e) { 
		LOG.error("WS getSiteTitle(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage(); 
	} 
	
	return siteTitle; 
}

/** 
* Get a site's description 
* 
* @param	sessionid	the id of a valid session
* @param	siteid		the id of the site you want the description of 
* @return				description of the site or string containing error 
* @throws	AxisFault 
* 
*/ 
public String getSiteDescription(String sessionid, String siteid) throws AxisFault { 

	Session s = establishSession(sessionid); 

	String siteDescription = ""; 
	
	try { 
		Site site = SiteService.getSite(siteid); 
		siteDescription = site.getDescription(); 
	} 
	catch (Exception e) { 
		LOG.error("WS getSiteDescription(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage(); 
	} 
	
	return siteDescription; 
}


/** 
* Get a site's skin 
* 
* @param	sessionid	the id of a valid session
* @param	siteid		the id of the site you want the skin of 
* @return				description of the site or string containing error 
* @throws	AxisFault 
* 
*/ 
public String getSiteSkin(String sessionid, String siteid) throws AxisFault { 

	Session s = establishSession(sessionid); 

	String siteSkin = ""; 
	
	try { 
		Site site = SiteService.getSite(siteid); 
		siteSkin = site.getSkin(); 
	} 
	catch (Exception e) { 
		LOG.error("WS getSiteSkin(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage(); 
	} 
	
	return siteSkin; 
}


/**
 * Get a site's joinable status
 *
 * @param	sessionid	the id of a valid session
 * @param	siteid		the id of the site you want the joinable status of
 * @return		        true if joinable, false if not or error (and logs any errors)
 * @throws	AxisFault	
 *
 */
public boolean isSiteJoinable(String sessionid, String siteid) throws AxisFault {
	Session s = establishSession(sessionid);
	
	try {
		Site site = SiteService.getSite(siteid);
		if(site.isJoinable()) {
			return true;
		} else {
			return false;
		}
	}
	catch (Exception e) {
		LOG.error("WS isSiteJoinable(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}



/**
 * Change the title of a site
 *
 * @param	sessionid	the id of a valid session
 * @param	siteid		the id of the site you want to change the title of
 * @param	title		the new title
 * @return		        success or string containing error
 * @throws	AxisFault	
 *
 */
public String changeSiteTitle(String sessionid, String siteid, String title) throws AxisFault {
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		siteEdit.setTitle(title);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS changeSiteTitle(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Change the skin of a site
 *
 * @param	sessionid	the id of a valid session
 * @param	siteid		the id of the site you want to change the skin of
 * @param	title		the new skin value (make sure its in /library/skin/<yourskin>)
 * @return		        success or string containing error
 * @throws	AxisFault	
 *
 */
public String changeSiteSkin(String sessionid, String siteid, String skin) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		siteEdit.setSkin(skin);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS changeSiteSkin(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}

/**
 * Make a site joinable or not, depending on the params sent
 *
 * @param	sessionid		the id of a valid session
 * @param	siteid			the id of the site you want to change the status of
 * @param	joinable		boolean if its joinable or not
 * @param	joinerrole		the role that users who join the site will be given
 * @param	publicview		boolean if the site is to be public or not. if its joinable it should probably be public so people can find it, but if its public it doesnt necessarily need to be joinable.
 * @return		        	success or string containing error
 * @throws	AxisFault	
 *
 */
public String changeSiteJoinable(String sessionid, String siteid, boolean joinable, String joinerrole, boolean publicview) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		siteEdit.setJoinable(joinable);
		siteEdit.setJoinerRole(joinerrole);
		siteEdit.setPubView(publicview);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS changeSiteJoinable(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Change the icon of a site (top left hand corner of site)
 *
 * @param	sessionid	the id of a valid session
 * @param	siteid	    the id of the site you want to change the icon of
 * @param	title	    the new icon value (publically accessible url - suggest its located in Resources for the site or another public location)
 * @return		        success or string containing error
 * @throws	AxisFault	
 *
 */
public String changeSiteIconUrl(String sessionid, String siteid, String iconurl) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {

		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		siteEdit.setIconUrl(iconurl);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) { 
		LOG.error("WS changeSiteIconUrl(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Change the description of a site
 *
 * @param	sessionid		the id of a valid session
 * @param	siteid	   		the id of the site you want to change the title of
 * @param	description	    the new description
 * @return		       		success or string containing error
 * @throws	AxisFault	
 *
 */
public String changeSiteDescription( String sessionid, String siteid, String description) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {
		
	    // check description
	    if (description != null) {
	        StringBuilder alertMsg = new StringBuilder();
	        description = FormattedText.processFormattedText(description, alertMsg);
	        if (description == null) {
	        	throw new AxisFault("Site description markup rejected: " + alertMsg.toString());
	        }
	    }            
	    
		Site siteEdit = null;
		siteEdit = SiteService.getSite(siteid);
		siteEdit.setDescription(description);
		SiteService.save(siteEdit);
	
	}
	catch (Exception e) {  
		LOG.error("WS changeSiteDescription(): " + e.getClass().getName() + " : " + e.getMessage());
	 	return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Get a custom property of a site
 *
 * @param	sessionid		the id of a valid session
 * @param	siteid			the id of the site you want to get the property from
 * @param	propname		the name of the property you want
 * @return		        	the property or blank if not found/property is blank
 * @throws	AxisFault	
 * 
 */
public String getSiteProperty(String sessionid, String siteid, String propname) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {
		//get site handle
		Site site = SiteService.getSite(siteid);
		
		//get list of properties for this site
		ResourceProperties props = site.getProperties();
		
		//get the property that we wanted, as a string. this wont return multi valued ones
		//would need to use getPropertyList() for that, but then need to return XML since its a list.
		String propvalue = props.getProperty(propname);
		return propvalue;	
		
	}
	catch (Exception e) {
		LOG.error("WS getSiteProperty(): " + e.getClass().getName() + " : " + e.getMessage());
		return "";
	}
}


/**
 * Set a custom property for a site
 *
 * @param	sessionid		the id of a valid session
 * @param	siteid			the id of the site you want to set the property for
 * @param	propname		the name of the property you want to set
 * @param	propvalue		the name of the property you want to set
 * @return		        	success if true or exception
 * @throws	AxisFault	
 *
 */
public String setSiteProperty(String sessionid, String siteid, String propname, String propvalue) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	if (!SecurityService.isSuperUser())
	{
		LOG.warn("WS setSiteProperty(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS setSiteProperty(): Permission denied. Restricted to super users.");
	}

	try {
		//get site handle
		Site site = SiteService.getSite(siteid);
		
		//get properties in edit mode
		ResourcePropertiesEdit props = site.getPropertiesEdit();
		
		//add property
		props.addProperty(propname, propvalue);
		
		//save site
		SiteService.save(site);
	
	}
	catch (Exception e) {
		LOG.error("WS setSiteProperty(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Remove a custom property for a site
 *
 * @param	sessionid		the id of a valid session
 * @param	siteid			the id of the site you want to remove the property from
 * @param	propname		the name of the property you want to remove
 * @return		        	success if true or exception
 * @throws	AxisFault	
 *
 */
public String removeSiteProperty( String sessionid, String siteid, String propname) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {
		//get site handle
		Site site = SiteService.getSite(siteid);
		
		//get properties in edit mode
		ResourcePropertiesEdit props = site.getPropertiesEdit();
		
		//remove property
		//if the property doesn't exist it will still return success. this is fine.
		props.removeProperty(propname);
		
		//save site
		SiteService.save(site);
	
	}
	catch (Exception e) {
		LOG.error("WS removeSiteProperty(): " + e.getClass().getName() + " : " + e.getMessage());
		return e.getClass().getName() + " : " + e.getMessage();
	}
	return "success";
}


/**
 * Check if a role exists in a given authzgroup
 *
 * @param	sessionid		the id of a valid session
 * @param	authzgroupid	the id of the authzgroup you want to check
 * @param	roleid			the id of the role you want to check for
 * @return		        	true/false
 * @throws	AxisFault	
 *
 */
public boolean checkForRoleInAuthzGroup(String sessionid, String authzgroupid, String roleid) throws AxisFault
{
	Session session = establishSession(sessionid);
	
	try {
		//open authzgroup
		AuthzGroup authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		
		//see if we can get the role in this authzgroup. will either return the Role, or null
		Role role = authzgroup.getRole(roleid);
		if(role != null) {
			return true;
		}
		return false;
	
	}
	catch (Exception e) {
		LOG.error("WS checkForRoleInAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}


/**
 * Search all the users that match this criteria in id or email, first or last name, returning
 * a subset of records within the record range given (sorted by sort name).
 * As of September 2008, the Sakai API that does the searching is not searching provided users
 * nor limiting the returned results (ie first and last are ignored)
 *
 * This web service is returning everything it receives correctly though, so when
 * UserDirectoryService.searchUsers() is amended, this will be even more complete.
 *
 * See: SAK-6792 and SAK-14268 for the releavnt Jira's tickets.
 *
 * @param	sessionid		the id of a valid session
 * @param	criteria		the search criteria.
 * @param	first			the first record position to return.
 * @param	last			the last record position to return.
 * @return		        	xml doc of list of records
 * @throws	AxisFault	
 *
 */
public String searchForUsers(String sessionid, String criteria, int first, int last) throws AxisFault
{
	Session session = establishSession(sessionid);
	

	try {
	
		//validate input
		if(("").equals(criteria)) {
			LOG.warn("WS searchForUsers(): no search criteria");
			return "<exception/>";
		}
		
		if(first == 0 || last == 0) {
			LOG.warn("WS searchForUsers(): invalid ranges");
			return "<exception/>";
		}
	
		List users = UserDirectoryService.searchUsers(criteria, first, last);
				
		Document dom = Xml.createDocument();
		Node list = dom.createElement("list");
		dom.appendChild(list);
		
		
		for (Iterator i = users.iterator(); i.hasNext();) {
			User user = (User) i.next();
			
			try {
									
				Node userNode = dom.createElement("user");
				
				Node userId = dom.createElement("id");
				userId.appendChild(dom.createTextNode(user.getId()));
				
				Node userEid = dom.createElement("eid");
				userEid.appendChild(dom.createTextNode(user.getEid()));
					
				Node userName = dom.createElement("name");
				userName.appendChild(dom.createTextNode(user.getDisplayName()));
				
				Node userEmail = dom.createElement("email");
				userEmail.appendChild(dom.createTextNode(user.getEmail()));
					
				userNode.appendChild(userId);
				userNode.appendChild(userEid);
				userNode.appendChild(userName);
				userNode.appendChild(userEmail);
				list.appendChild(userNode);
					
			} catch (Exception e) {
				//log this error and continue to the next user, otherwise we get nothing
				LOG.warn("WS searchForUsers(): " + e.getClass().getName() + " : " + e.getMessage());
			}
			
		}
		
		//add total size node (nice attribute to save the end user doing an XSLT count every time)
		Node total = dom.createElement("total");
		total.appendChild(dom.createTextNode(Integer.toString(users.size())));
		list.appendChild(total);
				
		return Xml.writeDocumentToString(dom);
	
	}
	catch (Exception e) {
		LOG.error("WS searchForUsers(): " + e.getClass().getName() + " : " + e.getMessage());
		return "<exception/>";

	}
}


/**
 * Check if an authzgroup exists, similar to checkForSite, but does authzgroup instead
 * (e.g. might be used to check if !site.template exists which checkForSite() cannot do.)
 *
 * @param	sessionid		the id of a valid session
 * @param	authzgroupid	the id of the authzgroup you want to check
 * @return		        	true if exists, false if not or error. 
 * @throws	AxisFault	
 *
 */
public boolean checkForAuthzGroup(String sessionid, String authzgroupid) throws AxisFault
{
	Session s = establishSession(sessionid);
	
	try {

		AuthzGroup authzgroup = null;
		authzgroup = AuthzGroupService.getAuthzGroup(authzgroupid);
		if (authzgroup != null) {
			return true;
		} else {
			return false;
		}
	}
	catch (Exception e) {
		LOG.error("WS checkForAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}


/**
 * Removes a member from a given site, similar to removeMembeForAuthzGroup but acts on Site directly
 *
 * @param	sessionid	the id of a valid session
 * @param	siteid		the id of the site you want to remove the user from
 * @return				success or string containing error 
 * @throws	AxisFault	
 *
 */
public String removeMemberFromSite(String sessionid, String siteid, String eid) throws AxisFault {

    Session session = establishSession(sessionid);

    try {
        Site site = SiteService.getSite(siteid);
        String userid = UserDirectoryService.getUserByEid(eid).getId();
        site.removeMember(userid);
        SiteService.save(site);
    } catch (Exception e) {
    	LOG.error("WS removeMemberFromSite(): " + e.getClass().getName() + " : " + e.getMessage());
        return e.getClass().getName() + " : " + e.getMessage();
    }
    return "success";
}



/**
 * Check if a user is in a particular authzgroup
 *
 * @param	sessionid		the id of a valid session, generally the admin user
 * @param	authzgroupid	the id of the authzgroup or site you want to check (if site: /site/SITEID)
 * @param	eid	        	the userid of the person you want to check
 * @return		        	true if in site, false if not or error. 
 * @throws	AxisFault	
 *
 */
public boolean checkForUserInAuthzGroup(String sessionid, String authzgroupid, String eid) throws AxisFault {
	Session s = establishSession(sessionid);
	
	if (ADMIN_SITE_REALM.equalsIgnoreCase(authzgroupid) && !SecurityService.isSuperUser(s.getUserId())) {
		LOG.warn("WS checkForUserInAuthzGroup(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS checkForUserInAuthzGroup(): Permission denied. Restricted to super users.");
	}

	try {		
		AuthzGroup azg = AuthzGroupService.getAuthzGroup(authzgroupid);
		for (Iterator i = azg.getUsers().iterator(); i.hasNext(); ) {
			String id = (String) i.next();
			User user = UserDirectoryService.getUser(id);
			if(user.getEid().equals(eid)) {
				return true;
			}
		}
		return false;		
	}
	catch (Exception e) {
	    LOG.error("WS checkForUserInAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return false;
	}
}


/** 
 * Get list of users in an authzgroup with the given role(s)
 *
 * @param	sessionid		the id of a valid session
 * @param	authzgroupid	the id of the authzgroup, site or group you want to get the users in (if site: /site/SITEID, if group: /site/SITEID/group/GROUPID)
 * @param	authzgrouproles	the roles that you want to filter on (string with spaces as delimiters)
 * @return		        	xml doc of the list of users, display name and roleid
 * @throws	AxisFault		returns <exception /> string if exception encountered and logs it	
 *
 */
public String getUsersInAuthzGroupWithRole(String sessionid, String authzgroupid, String authzgrouproles) throws AxisFault {
	
	Session s = establishSession(sessionid);
	
	if (ADMIN_SITE_REALM.equalsIgnoreCase(authzgroupid) && !SecurityService.isSuperUser(s.getUserId())) {
		LOG.warn("WS getUsersInAuthzGroupWithRole(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS getUsersInAuthzGroupWithRole(): Permission denied. Restricted to super users.");
	}
	
	try {
		
		AuthzGroup azg = AuthzGroupService.getAuthzGroup(authzgroupid);
		
		Document dom = Xml.createDocument();
		Node list = dom.createElement("list");
		dom.appendChild(list);

		//split the authzgroup roles into a string[] then add into arraylist. 
		//Done this way so we dont need any extra imports (ie using List<String> authzgrouprolesList = Arrays.asList(authzgrouprolesArr));
		String[] authzgrouprolesArr = authzgrouproles.split(" ");
		ArrayList<String> authzgrouprolesList = new ArrayList<String>();
		for(int i=0; i< authzgrouprolesArr.length; i++) {
			authzgrouprolesList.add(authzgrouprolesArr[i]);
		}

		//iterate over each role in the list...
		for (Iterator j = authzgrouprolesList.iterator(); j.hasNext(); ) {
			String role = (String) j.next();
		
			//now get all the users in the authzgroup with this role and add to xml doc
			for (Iterator k = azg.getUsersHasRole(role).iterator(); k.hasNext(); ) {
				String id = (String) k.next();
	
				try {
					User user = UserDirectoryService.getUser(id);				
					Node userNode = dom.createElement("user");
					Node userId = dom.createElement("id");
					userId.appendChild(dom.createTextNode(user.getEid()));
					Node userName = dom.createElement("name");
					userName.appendChild(dom.createTextNode(user.getDisplayName()));
					Node userRole = dom.createElement("role");
					userRole.appendChild(dom.createTextNode(role));
					
					userNode.appendChild(userId);
					userNode.appendChild(userName);
					userNode.appendChild(userRole);
					list.appendChild(userNode);
					
				} catch (Exception e) {
					//Exception with this user, log the error, skip this user and continue to the next
					LOG.warn("WS getUsersInAuthzGroupWithRole(): error processing user " + id + " : " + e.getClass().getName() + " : " + e.getMessage());
				}
			}
		}
		return Xml.writeDocumentToString(dom);
	}
	catch (Exception e) {
        LOG.error("WS getUsersInAuthzGroupWithRole(): " + e.getClass().getName() + " : " + e.getMessage());
		return "<exception/>";

	}
}


/**
 * Gets list of ALL users in an authzgroup
 *
 * 
 * @param	sessionid		the id of a valid session
 * @param	authzgroupid	the id of the authzgroup, site or group you want to get the users in (if site: /site/SITEID, if group: /site/SITEID/group/GROUPID)
 * @return					xml doc of the list of users, display name and roleid
 * @throws	AxisFault		returns <exception /> string if exception encountered	
 *
 *
 */
public String getUsersInAuthzGroup(String sessionid, String authzgroupid) throws AxisFault {
	
	Session s = establishSession(sessionid);
	
	if (ADMIN_SITE_REALM.equalsIgnoreCase(authzgroupid) && !SecurityService.isSuperUser(s.getUserId())) {
		LOG.warn("WS getUsersInAuthzGroup(): Permission denied. Restricted to super users.");
		throw new AxisFault("WS getUsersInAuthzGroup(): Permission denied. Restricted to super users.");
	}

	try {
		
		AuthzGroup azg = AuthzGroupService.getAuthzGroup(authzgroupid);
		
		Document dom = Xml.createDocument();
		Node list = dom.createElement("list");
		dom.appendChild(list);
		
		for (Iterator i = azg.getUsers().iterator(); i.hasNext(); ) {
			String id = (String) i.next();
			try {
				User user = UserDirectoryService.getUser(id);
				
				//wrapping user node
				Node userNode = dom.createElement("user");
				
				//id child node
				Node userId = dom.createElement("id");
				userId.appendChild(dom.createTextNode(user.getEid()));
				
				//name child node
				Node userName = dom.createElement("name");
				userName.appendChild(dom.createTextNode(user.getDisplayName()));
				
				//role child node
				Node userRole = dom.createElement("role");
				String role = azg.getUserRole(id).getId();
				userRole.appendChild(dom.createTextNode(role));
				
				//add all clicd nodes into the parent node
				userNode.appendChild(userId);
				userNode.appendChild(userName);
				userNode.appendChild(userRole);
				list.appendChild(userNode);
				
			} catch (Exception e) {
				//Exception with this user, log the error, skip this user and continue to the next
				LOG.warn("WS getUsersInAuthzGroup(): error processing user " + id + " : " + e.getClass().getName() + " : " + e.getMessage());
			}
		}
		return Xml.writeDocumentToString(dom);
	}
	catch (Exception e) {
        LOG.error("WS getUsersInAuthzGroup(): " + e.getClass().getName() + " : " + e.getMessage());
		return "<exception/>";
	}
}





/** 
 * Copy the calendar events from one site to another
 *
 * @param	sessionid		the id of a valid session
 * @param	sourceSiteId	the id of the site containing the calendar entries you want copied
 * @param	targetSiteId	the roles that you want to filter on (string with spaces as delimiters)
 * @return		        	success or exception
 * @throws	AxisFault		
 *
 */
public String copyCalendarEvents(String sessionid, String sourceSiteId, String targetSiteId) throws AxisFault { 

	Session session = establishSession(sessionid); 
	
	//setup source and target calendar strings
	String calId1 = "/calendar/calendar/"+sourceSiteId+"/main"; 
	String calId2 = "/calendar/calendar/"+targetSiteId+"/main"; 
	
	Calendar calendar1 = null;
	CalendarEdit calendar2 = null;
	try { 
		//get calendars
		calendar1 = CalendarService.getCalendar(calId1); 
		calendar2 = CalendarService.editCalendar(calId2); 
	
		//for every event in calendar1, add it to calendar2
		List eventsList = calendar1.getEvents(null, null); 
	
		for (Iterator i = eventsList.iterator(); i.hasNext();) { 
			CalendarEvent cEvent = (CalendarEvent) i.next(); 
			CalendarEventEdit cedit = calendar2.addEvent(); 
			cedit.setRange(cEvent.getRange()); 
			cedit.setDisplayName(cEvent.getDisplayName()); 
			cedit.setDescription(cEvent.getDescription()); 
			cedit.setType(cEvent.getType()); 
			cedit.setLocation(cEvent.getLocation()); 
			cedit.setDescriptionFormatted(cEvent.getDescriptionFormatted()); 
			cedit.setRecurrenceRule(cEvent.getRecurrenceRule()); 
			calendar2.commitEvent(cedit); 
			//LOG.warn(cEvent.getDisplayName()); 
		}
		//save calendar 2
		CalendarService.commitCalendar(calendar2); 
		
	} catch (Exception e) { 
		CalendarService.cancelCalendar(calendar2);
		LOG.error("WS copyCalendarEvents(): error " + e.getClass().getName() + " : " + e.getMessage()); 
		return e.getClass().getName() + " : " + e.getMessage(); 
	} 
	return "success"; 
} 




}
